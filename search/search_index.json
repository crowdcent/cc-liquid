{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>\u26a0\ufe0f PRE-ALPHA SOFTWARE - USE AT YOUR OWN RISK \u26a0\ufe0f</p> <ul> <li>Using this software may result in COMPLETE LOSS of funds</li> <li>CrowdCent makes NO WARRANTIES and assumes NO LIABILITY</li> <li>Users must comply with Hyperliquid terms of service</li> <li>We do NOT endorse any strategies using this tool</li> </ul> <p><code>cc-liquid</code> is a reference implementation for simple, automated portfolio rebalancing on Hyperliquid driven by metamodel predictions.</p> <p></p>"},{"location":"#what-you-can-do","title":"What you can do","text":"<ul> <li>Download CrowdCent or Numerai metamodel predictions</li> <li>Inspect account, positions, and exposure</li> <li>Rebalance to long/short target sets with equal-weight sizing</li> <li>Run continuously on a schedule (autopilot)</li> </ul>"},{"location":"#tldr","title":"TL;DR","text":"<pre><code>uv tool install cc-liquid\ncc-liquid init       # interactive setup wizard\ncc-liquid account    # test connection &amp; view positions\ncc-liquid rebalance  # plan and execute trades\ncc-liquid run        # run continuously on auto-pilot\n</code></pre> <p>See Install &amp; Quick Start for setup, environment variables, and first run. New users should try testnet first: <code>--set is_testnet=true</code>.</p> <p>Legal Disclaimer</p> <p>THIS SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED. USERS ASSUME ALL RISKS INCLUDING COMPLETE LOSS OF FUNDS, TRADING LOSSES, TECHNICAL FAILURES, AND LIQUIDATION RISKS.</p>"},{"location":"autopilot/","title":"Autopilot & Scheduling","text":"<p>Autopilot runs a live dashboard and executes rebalances on your schedule.</p>"},{"location":"autopilot/#run-autopilot","title":"Run autopilot","text":"<pre><code>cc-liquid run --skip-confirm\n</code></pre> <p>Flags:</p> <ul> <li><code>--skip-confirm</code>: execute without confirmation when due</li> <li><code>--tmux</code>: run monitor within a tmux session/window</li> <li><code>--set</code>: override config at runtime</li> <li><code>--refresh</code>: UI refresh cadence in seconds (default 1.0)</li> </ul> <p>Run inside tmux (advanced)</p> <p>For long-running sessions, you can run the dashboard in a fixed tmux session. This will attach to the session if it already exists, or create it and start the loop if not.</p> <p>Start (or attach) with uv:</p> <pre><code>uv run cc-liquid run --tmux --skip-confirm\n</code></pre> <ul> <li>Detach with Ctrl-B and continue using your machine. </li> <li>Re-attach later: <code>tmux attach -t cc-liquid</code> or <code>cc-liquid run --tmux</code></li> <li>Stop the loop with Ctrl-C. The session stays open until you exit/kill it.</li> </ul>"},{"location":"autopilot/#schedule","title":"Schedule","text":"<p>Configure in <code>cc-liquid-config.yaml</code>:</p> <pre><code>portfolio:\n  rebalancing:\n    every_n_days: 10\n    at_time: \"18:15\"   # UTC\n</code></pre> <p>The next time is computed from the last successful rebalance timestamp, stored in <code>.cc_liquid_state.json</code>.</p> <p>State details:</p> <ul> <li>The file stores <code>last_rebalance_date</code> as ISO-8601 UTC.</li> <li>If no state is present, the next run is scheduled for today at <code>portfolio.rebalancing.at_time</code> (or immediately if already past).</li> <li>Each successful cycle updates the timestamp.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>cc-liquid loads configuration from <code>cc-liquid-config.yaml</code> and environment variables. Addresses, profile selection, and portfolio parameters live in the config YAML; secrets (private keys, API keys) should live in <code>.env</code>. You can override any setting via <code>--set</code> when running the CLI commands.</p>"},{"location":"configuration/#environment-variables-env","title":"Environment variables (.env)","text":"<p>Secrets only:</p> <pre><code>CROWDCENT_API_KEY=zzxFakeCr.owdCentKey1234567890   # (needed for CrowdCent metamodel source)\nHYPERLIQUID_PRIVATE_KEY=0xdeadbeefdeadbeefdeadbeefdeadbeefdead  # (default signer key variable name)\n</code></pre> <p>Note</p> <ul> <li> <p>You can change the default signer key variable name and provide additional, profile-specific signer keys you can reference via <code>signer_env</code> in YAML, (e.g.:<code>HYPER_AGENT_KEY_PERSONAL</code>, <code>HYPER_AGENT_KEY_VAULT</code>)</p> </li> <li> <p>Do not put addresses in <code>.env</code>; keep owner/vault addresses in the configuration YAML file.</p> </li> </ul>"},{"location":"configuration/#yaml-cc-liquid-configyaml","title":"YAML (<code>cc-liquid-config.yaml</code>)","text":"<pre><code>is_testnet: false\n\nactive_profile: default\n\nprofiles:\n  default:\n    owner: 0xYourMain\n    vault: null                 # omit or null for personal portfolio\n    signer_env: HYPERLIQUID_PRIVATE_KEY\n\n  my-vault:\n    owner: 0xYourMain           # optional, informational\n    vault: 0xVaultAddress\n    signer_env: HYPERLIQUID_AGENT_KEY_VAULT\n\n\ndata:\n  source: crowdcent | numerai | local\n  path: predictions.parquet\n  date_column: release_date | date\n  asset_id_column: id | symbol\n  prediction_column: pred_10d | meta_model\n\nportfolio:\n  num_long: 10\n  num_short: 10\n  target_leverage: 1.0\n  rebalancing:\n    every_n_days: 10\n    at_time: \"18:15\"   # HH:MM (UTC)\n\nexecution:\n  slippage_tolerance: 0.005\n  min_trade_value: 10.0\n</code></pre>"},{"location":"configuration/#profiles-network-credentials","title":"Profiles, network &amp; credentials","text":"<ul> <li><code>profiles</code> define who you trade for and which key signs.</li> <li><code>owner</code>: portfolio owner (used for Info queries when <code>vault</code> not set)</li> <li><code>vault</code>: optional; when set, becomes the portfolio owner for Info and Exchange endpoint includes <code>vaultAddress</code></li> <li><code>signer_env</code>: name of env var holding the private key for signing</li> <li><code>active_profile</code> selects the default profile, override with <code>set --active_profile</code> at runtime</li> <li><code>is_testnet: true</code> switches from mainnet to testnet</li> </ul> <p>See more on how to generate Hyperliquid API wallets and private keys for safety: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/nonces-and-api-wallets</p>"},{"location":"configuration/#data","title":"Data","text":"<p>Source types; columns can be overridden):</p>"},{"location":"configuration/#crowdcent","title":"crowdcent","text":"<pre><code>cc-liquid rebalance --set data.source=crowdcent\n</code></pre> <p>Defaults: <code>date_column=release_date</code>, <code>asset_id_column=id</code>, <code>prediction_column=pred_10d</code>, <code>path=predictions.parquet</code></p>"},{"location":"configuration/#numerai","title":"numerai","text":"<p>Ensure you have installed extras: <code>uv pip install cc-liquid[numerai]</code></p> <pre><code>cc-liquid rebalance --set data.source=numerai\n</code></pre> <p>Defaults: <code>date_column=date</code>, <code>asset_id_column=symbol</code>, <code>prediction_column=meta_model</code>, <code>path=predictions.parquet</code></p> <p>Tip</p> <p>Running commands with --set <code>data.source=numerai</code> can auto-apply column defaults for the Numerai metamodel.</p>"},{"location":"configuration/#local","title":"local","text":"<p>Bring your own Parquet/CSV:</p> <pre><code>cc-liquid rebalance \\\n  --set data.source=local \\\n  --set data.path=my_preds.parquet \\\n  --set data.date_column=dt \\\n  --set data.asset_id_column=ticker \\\n  --set data.prediction_column=score\n</code></pre> <p>Column rules:</p> <ul> <li><code>date_column</code>: latest row per asset is used</li> <li><code>asset_id_column</code>: must match Hyperliquid symbols; unmatched are skipped</li> <li><code>prediction_column</code>: ranking for longs/shorts grouped by date</li> </ul>"},{"location":"configuration/#portfolio","title":"Portfolio","text":"<ul> <li><code>num_long</code> / <code>num_short</code>: counts for top/bottom selections</li> <li><code>target_leverage</code>: - scales notional per-position: <code>(account_value * target_leverage) / (num_long + num_short)</code>.</li> <li><code>rebalancing.every_n_days</code> / <code>rebalancing.at_time</code> (UTC)</li> </ul>"},{"location":"configuration/#execution","title":"Execution","text":"<ul> <li><code>slippage_tolerance</code>: used for market orders</li> <li><code>min_trade_value</code>: trades below this absolute USD delta are skipped</li> </ul>"},{"location":"configuration/#cli-overrides","title":"CLI overrides","text":"<p>Examples:</p> <pre><code>cc-liquid run --set active_portfolio=default\n</code></pre> <pre><code>cc-liquid rebalance --set data.source=numerai --set portfolio.target_leverage=2.0 --set portfolio.num_long=12\n</code></pre> <p>Nested keys use dot-notation. Types are inferred (int/float/bool/str).</p> <p>Smart defaults when switching <code>data.source</code> are applied unless explicitly overridden.</p>"},{"location":"configuration/#cli-helpers","title":"CLI helpers","text":"<ul> <li><code>cc-liquid profile list | show | use &lt;name&gt;</code> \u2013 manage profiles</li> </ul>"},{"location":"headless/","title":"Headless & Custom Callbacks","text":"<p>Use cc-liquid as a library without the CLI UI. The core trading logic is UI-agnostic and driven by callbacks.</p>"},{"location":"headless/#callback-protocol","title":"Callback protocol","text":"<ul> <li>Implement <code>cc_liquid.callbacks.CCLiquidCallbacks</code> to receive lifecycle events (info/warn/error, trade start/fill/fail, batch complete, confirmation prompts, etc.).</li> <li>Use <code>cc_liquid.callbacks.NoOpCallbacks</code> to run headless without output, or <code>cc_liquid.cli_callbacks.RichCLICallbacks</code> for the rich TUI.</li> </ul>"},{"location":"headless/#programmatic-usage","title":"Programmatic usage","text":"<p>Minimal headless run with your own predictions:</p> <pre><code>import polars as pl\nfrom cc_liquid.config import Config\nfrom cc_liquid.trader import CCLiquid\nfrom cc_liquid.callbacks import NoOpCallbacks\n\n# Load env + YAML; apply any config file you have in cwd\ncfg = Config()\n\n# Example: use a local parquet with your own column names\npreds = pl.read_parquet(\"predictions.parquet\")\n\nbot = CCLiquid(cfg, callbacks=NoOpCallbacks())\n\n# Compute plan using provided predictions (skips loading by source)\nplan = bot.plan_rebalance(predictions=preds)\n\n# Inspect or modify plan[\"trades\"] as needed, then execute\nresult = bot.execute_plan(plan)\nprint({\n    \"num_success\": len(result[\"successful_trades\"]),\n    \"num_total\": len(result[\"all_trades\"]),\n})\n</code></pre> <p>Notes:</p> <ul> <li>If you let the bot load predictions, set <code>cfg.data.source</code> and related columns first.</li> <li>Trades below <code>execution.min_trade_value</code> are reported in <code>plan[\"skipped_trades\"]</code>.</li> </ul>"},{"location":"headless/#scheduling-without-cli","title":"Scheduling (without CLI)","text":"<p>The bot exposes helpers for simple scheduling and state persistence:</p> <pre><code>from datetime import UTC, datetime\n\nlast = bot.load_state()  # reads .cc_liquid_state.json if present\nnext_time = bot.compute_next_rebalance_time(last)\nif datetime.now(UTC) &gt;= next_time:\n    plan = bot.plan_rebalance()\n    res = bot.execute_plan(plan)\n    bot.save_state(datetime.now(UTC))\n</code></pre>"},{"location":"how-it-works/","title":"How it works","text":"<p>High-level flow of a rebalance:</p> <p>1) Load predictions</p> <ul> <li>From CrowdCent, Numerai, or a local file into a Polars DataFrame</li> <li>Keep latest row per asset based on <code>date_column</code></li> </ul> <p>2) Select assets</p> <ul> <li>Top <code>num_long</code> as longs and bottom <code>num_short</code> as shorts by <code>prediction_column</code></li> <li>Filter to perpetuals currently listed on Hyperliquid</li> </ul> <p>3) Size positions</p> <ul> <li>Equal-weight notional per position: <code>(account_value * target_leverage) / total_positions</code><ul> <li>Warn if below <code>execution.min_trade_value</code></li> </ul> </li> </ul> <p>4) Generate trades</p> <ul> <li>Compare current value vs target value per asset to compute deltas<ul> <li>Round size to <code>sz_decimals</code> per asset (from exchange metadata)</li> <li>Trades with absolute delta below <code>execution.min_trade_value</code> are marked as skipped (reported separately)</li> </ul> </li> </ul> <p>5) Execute</p> <ul> <li>Market open via Hyperliquid SDK with <code>execution.slippage_tolerance</code><ul> <li>Report fills, failures, and slippage; summarize execution</li> <li>Unfilled or error statuses are surfaced with reasons; successful fills include <code>totalSz</code> and <code>avgPx</code></li> </ul> </li> </ul> <p>Scheduling</p> <ul> <li>The autopilot loop computes the next rebalance time in UTC from <code>portfolio.rebalancing</code></li> <li>When due, it generates a plan, asks for confirmation (or uses <code>--skip-confirm</code>), executes, and saves the timestamp</li> <li>Last successful timestamp is stored locally in <code>.cc_liquid_state.json</code></li> </ul>"},{"location":"install-quickstart/","title":"Install & Quick Start","text":"<p>This page gets you running in minutes.</p>"},{"location":"install-quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Hyperliquid API/Agent wallet (address + private key)</li> <li>Optional: CrowdCent API key</li> </ul>"},{"location":"install-quickstart/#install","title":"Install","text":"<p>If uv is not installed, install:</p> macOS / LinuxWindows (PowerShell) <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Then, install cc-liquid as a CLI tool: <pre><code>uv tool install cc-liquid\n# Optional Numerai support\nuv tool install cc-liquid[numerai]\n</code></pre></p>"},{"location":"install-quickstart/#or-run-without-directly-installing-uvx","title":"Or run without directly installing (uvx)","text":"<pre><code>uvx cc-liquid init\n</code></pre>"},{"location":"install-quickstart/#first-time-setup","title":"First-time setup","text":"<pre><code>cc-liquid init               # interactive setup wizard (recommended)\ncc-liquid init --non-interactive  # use safe defaults without prompts\n</code></pre> <p>The wizard will guide you through: - Choosing testnet vs mainnet (defaults to testnet for safety) - Selecting data source (CrowdCent, Numerai, or local) - Entering API keys (with links to get them) - Setting up portfolio parameters - Auto-adding <code>.env</code> to <code>.gitignore</code> for security</p>"},{"location":"install-quickstart/#enable-tab-auto-completion-in-your-shell-optional","title":"Enable tab auto-completion in your shell (optional)","text":"<p>Tabs for commands, options, and values.</p> <pre><code>cc-liquid completion install          # auto-detects your shell\n</code></pre> <p>Manual equivalent:</p> BashZshFish <pre><code>_CC_LIQUID_COMPLETE=bash_source cc-liquid &gt; ~/.cc-liquid-complete.bash\necho '. ~/.cc-liquid-complete.bash' &gt;&gt; ~/.bashrc\n</code></pre> <pre><code>_CC_LIQUID_COMPLETE=zsh_source cc-liquid &gt; ~/.cc-liquid-complete.zsh\necho '. ~/.cc-liquid-complete.zsh' &gt;&gt; ~/.zshrc\n</code></pre> <pre><code>mkdir -p ~/.config/fish/completions\n_CC_LIQUID_COMPLETE=fish_source cc-liquid &gt; ~/.config/fish/completions/cc-liquid.fish\n</code></pre> <p>Restart your shell to activate completion, or run <code>source ~/.bashrc</code>, <code>source ~/.zshrc</code>, etc. as needed. See Click Shell Completion for details.</p>"},{"location":"install-quickstart/#configure","title":"Configure","text":"<p>After running <code>cc-liquid init</code>, you'll have two files:</p> <p>1) <code>.env</code> - Contains your secrets (auto-added to .gitignore):</p> <pre><code># Secrets only - NEVER commit this file to git!\nCROWDCENT_API_KEY=...                # from https://crowdcent.com/profile\nHYPERLIQUID_PRIVATE_KEY=0x...        # from https://app.hyperliquid.xyz/API\n</code></pre> <p>2) <code>cc-liquid-config.yaml</code> - Your trading configuration:</p> <pre><code>active_profile: personal\n\nprofiles:\n  personal:\n    owner: 0xYourMain\n    vault: null\n    signer_env: HYPER_AGENT_KEY_PERSONAL\n\ndata:\n  source: crowdcent         # crowdcent | numerai | local\n  path: predictions.parquet\n  date_column: release_date\n  asset_id_column: id\n  prediction_column: pred_10d\n\nportfolio:\n  num_long: 10\n  num_short: 10\n  target_leverage: 1.0\n  rebalancing:\n    every_n_days: 10\n    at_time: \"18:15\"\n\nexecution:\n  slippage_tolerance: 0.005\n</code></pre>"},{"location":"install-quickstart/#first-run","title":"First run","text":"<pre><code>cc-liquid config     # verify config is loaded\ncc-liquid account    # view account and positions\ncc-liquid rebalance  # plan and execute trades (prompts for confirmation)\n</code></pre> <p>Use overrides without editing files:</p> <pre><code>cc-liquid rebalance --set data.source=numerai --set portfolio.num_long=20 --set portfolio.target_leverage=2.0\n</code></pre>"},{"location":"install-quickstart/#testnet-first-recommended","title":"Testnet first (recommended)","text":"<p>To avoid live trading while getting set up, use Hyperliquid testnet:</p> <p>Use a testnet profile or override <code>network: testnet</code>:</p> <pre><code>cc-liquid rebalance --set is_testnet=true   # or set profile.network=testnet\n</code></pre>"},{"location":"install-quickstart/#autopilot-continuous","title":"Autopilot (continuous)","text":"<p>Runs a live dashboard and executes on your schedule.</p> <pre><code>cc-liquid run --skip-confirm   # WARNING: executes trades automatically\n</code></pre> <p>See the User Guide for a deeper walkthrough.</p>"},{"location":"security/","title":"Security & Disclaimer","text":"<p>Keep secrets safe and understand the risks.</p>"},{"location":"security/#secrets-hygiene","title":"Secrets hygiene","text":"<ul> <li>Store keys only in a local <code>.env</code> file (see Install &amp; Quick Start \u2192 Configure and Configuration \u2192 Environment variables)</li> <li>Never commit <code>.env</code> (already gitignored)</li> <li>Use a dedicated API/Agent wallet separate from main funds</li> </ul>"},{"location":"security/#operational-risk","title":"Operational risk","text":"<ul> <li>Autopilot can execute trades automatically (<code>--skip-confirm</code>) (see Autopilot &amp; Scheduling)</li> <li>Leverage increases risk of liquidation</li> <li>Network/API failures can cause missed or partial rebalances</li> </ul>"},{"location":"security/#legal-disclaimer","title":"Legal disclaimer","text":"<p>THIS SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>This is PRE-ALPHA software intended as a reference implementation only. Users assume ALL risks associated with using this software, including but not limited to: - Complete loss of funds - Trading losses - Technical failures - Liquidation risks - Any other financial losses</p> <p>CrowdCent does not endorse, recommend, or provide support for any trading strategies, vaults, or implementations using this software. Users must independently verify all functionality and assume full responsibility for their trading decisions.</p> <p>By using this software, you agree to comply with all applicable laws and regulations, including Hyperliquid's terms of service.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and fixes.</p>"},{"location":"troubleshooting/#missing-environment-variables","title":"Missing environment variables","text":"<p>Error: <code>HYPERLIQUID_PRIVATE_KEY must be set in .env file.</code></p> <ul> <li>Ensure <code>.env</code> exists with <code>HYPERLIQUID_PRIVATE_KEY</code> or a profile-specific <code>signer_env</code> key</li> </ul> <p>Error: <code>CROWDCENT_API_KEY not found in environment variables</code></p> <ul> <li>Add <code>CROWDCENT_API_KEY</code> for CrowdCent data, or switch to <code>local</code>/<code>numerai</code></li> </ul>"},{"location":"troubleshooting/#no-tradeable-assets","title":"No tradeable assets","text":"<p>Warning: <code>No predictions match Hyperliquid tradeable assets!</code></p> <ul> <li>Ensure prediction <code>asset_id_column</code> matches Hyperliquid coins (e.g., BTC, ETH)</li> <li>Use the correct <code>data.source</code> smart defaults or set columns explicitly</li> </ul>"},{"location":"troubleshooting/#trades-skipped-below-minimum","title":"Trades skipped (below minimum)","text":"<ul> <li>Increase <code>account_value</code> or <code>portfolio.target_leverage</code></li> <li>Reduce <code>portfolio.num_long/num_short</code></li> <li>Lower <code>execution.min_trade_value</code> with caution</li> </ul>"},{"location":"troubleshooting/#high-slippage-or-failed-orders","title":"High slippage or failed orders","text":"<ul> <li>Increase <code>execution.slippage_tolerance</code></li> <li>Reduce position count or leverage</li> <li>Avoid illiquid symbols (see Configuration \u2192 Execution)</li> </ul>"},{"location":"troubleshooting/#testnet-vs-mainnet","title":"Testnet vs Mainnet","text":"<ul> <li>Use <code>--set is_testnet=true</code> to switch networks</li> </ul>"},{"location":"walkthrough/","title":"User Guide","text":"<p>This walkthrough explains the core flow and safe first steps.</p>"},{"location":"walkthrough/#1-install-and-configure","title":"1) Install and configure","text":"<p>Follow Install &amp; Quick Start to install and create <code>.env</code>. Optionally copy <code>cc-liquid-config.yaml</code> and tune values.</p> <p>Tip: enable tab autocompletion for a smoother CLI experience</p> <pre><code>cc-liquid completion install\n</code></pre>"},{"location":"walkthrough/#2-choose-a-data-source","title":"2) Choose a data source","text":"<p>Set in <code>cc-liquid-config.yaml</code> or via <code>--set</code>:</p> <ul> <li><code>crowdcent</code>: latest consolidated metamodel from CrowdCent</li> <li><code>numerai</code>: Numerai Crypto metamodel</li> <li><code>local</code>: your own parquet/csv file</li> </ul> <p>Examples:</p> <pre><code>cc-liquid download-crowdcent -o predictions.parquet\ncc-liquid download-numerai -o predictions.parquet\n</code></pre> <p>See configuration for column defaults and overrides: Configuration \u2192 Data</p>"},{"location":"walkthrough/#3-inspect-account-and-positions","title":"3) Inspect account and positions","text":"<pre><code>cc-liquid account\n</code></pre>"},{"location":"walkthrough/#4-dry-run-a-plan-prompted","title":"4) Dry-run a plan (prompted)","text":"<pre><code>cc-liquid rebalance\n</code></pre> <p>The CLI will display a plan with target positions and trades; confirm to execute. You can adjust on the fly:</p> <pre><code>cc-liquid rebalance --set portfolio.num_long=12 --set portfolio.num_short=8 --set portfolio.target_leverage=2.0\n</code></pre>"},{"location":"walkthrough/#flatten-close-all-positions","title":"Flatten (close all positions)","text":"<pre><code>cc-liquid close-all --skip-confirm\n</code></pre> <p>This plans and executes trades to return to cash. Omit <code>--skip-confirm</code> to review first.</p>"},{"location":"walkthrough/#5-continuous-mode-autopilot","title":"5) Continuous mode (autopilot)","text":"<p>Schedules execution at <code>portfolio.rebalancing.at_time</code> every <code>every_n_days</code>.</p> <pre><code>cc-liquid run --skip-confirm   # executes automatically on schedule\n</code></pre>"},{"location":"walkthrough/#safety-notes","title":"Safety notes","text":"<ul> <li>Leverage increases liquidation risk; start with 1.0x</li> <li>Ensure <code>execution.min_trade_value</code> and slippage are appropriate</li> <li>Use Hyperliquid testnet first (<code>--set is_testnet=true</code>)</li> </ul>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides auto-generated documentation for the <code>cc-liquid</code> CLI tool.</p>"},{"location":"api/cli/#cc-liquid","title":"cc-liquid","text":"<p>cc-liquid - A metamodel-based rebalancer for Hyperliquid.</p> <p>Usage:</p> <pre><code>cc-liquid [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-account","title":"cc-liquid account","text":"<p>Show comprehensive account and positions summary.</p> <p>Usage:</p> <pre><code>cc-liquid account [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-close-all","title":"cc-liquid close-all","text":"<p>Close all positions and return to cash.</p> <p>Usage:</p> <pre><code>cc-liquid close-all [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --skip-confirm  Skip confirmation prompt for closing positions.\n  --set TEXT      Override config values (e.g., --set is_testnet=true)\n  --force         Force close positions below min notional by composing a two-\n                  step workaround.\n  --help          Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-completion","title":"cc-liquid completion","text":"<p>Shell completion utilities.</p> <p>Usage:</p> <pre><code>cc-liquid completion [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-completion-install","title":"cc-liquid completion install","text":"<p>Install shell completion for the current user.</p> <p>Writes the generated completion script to a standard location and, for Bash/Zsh, appends a source line to the user's rc file idempotently.</p> <p>Usage:</p> <pre><code>cc-liquid completion install [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --shell [bash|zsh|fish]  Target shell. Defaults to auto-detect from $SHELL.\n  --prog-name TEXT         Program name to install completion for (as\n                           installed on PATH).  [default: cc-liquid]\n  --help                   Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-config","title":"cc-liquid config","text":"<p>Show the current configuration.</p> <p>Usage:</p> <pre><code>cc-liquid config [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-download-crowdcent","title":"cc-liquid download-crowdcent","text":"<p>Download the CrowdCent meta model.</p> <p>Usage:</p> <pre><code>cc-liquid download-crowdcent [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -o, --output TEXT  Output file path (defaults to path in config).\n  --help             Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-download-numerai","title":"cc-liquid download-numerai","text":"<p>Download the Numerai meta model.</p> <p>Usage:</p> <pre><code>cc-liquid download-numerai [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -o, --output TEXT  Output file path (defaults to path in config).\n  --help             Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-init","title":"cc-liquid init","text":"<p>Interactive setup wizard for first-time users.</p> <p>Guides you through creating config files with validation and helpful defaults.</p> <p>Usage:</p> <pre><code>cc-liquid init [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --non-interactive  Skip interactive setup, use defaults\n  --help             Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-profile","title":"cc-liquid profile","text":"<p>Manage configuration profiles (owner/vault/signer).</p> <p>Usage:</p> <pre><code>cc-liquid profile [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-profile-list","title":"cc-liquid profile list","text":"<p>List available profiles from YAML and highlight the active one.</p> <p>Usage:</p> <pre><code>cc-liquid profile list [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-profile-show","title":"cc-liquid profile show","text":"<p>Show details for a profile (defaults to active).</p> <p>Usage:</p> <pre><code>cc-liquid profile show [OPTIONS] [NAME]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-profile-use","title":"cc-liquid profile use","text":"<p>Set active profile and persist to YAML.</p> <p>Usage:</p> <pre><code>cc-liquid profile use [OPTIONS] NAME\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-rebalance","title":"cc-liquid rebalance","text":"<p>Execute rebalancing based on the configured data source.</p> <p>Usage:</p> <pre><code>cc-liquid rebalance [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --skip-confirm  Skip confirmation prompt for executing trades.\n  --set TEXT      Override config values (e.g., --set data.source=numerai\n                  --set portfolio.num_long=10)\n  --help          Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-run","title":"cc-liquid run","text":"<p>Start continuous monitoring and automatic rebalancing with live dashboard.</p> <p>Usage:</p> <pre><code>cc-liquid run [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --skip-confirm   Skip confirmation prompt for executing trades.\n  --set TEXT       Override config values (e.g., --set is_testnet=true)\n  --refresh FLOAT  Dashboard update cadence in seconds.  [default: 1.0]\n  --tmux           Run inside a fixed tmux session (attach if exists, else\n                   create and run).\n  --help           Show this message and exit.\n</code></pre>"},{"location":"api/python/","title":"Python API reference","text":"<p>This package is primarily a CLI. The core modules are documented below for advanced users.</p>"},{"location":"api/python/#config","title":"Config","text":""},{"location":"api/python/#cc_liquid.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Manages configuration for the trading bot, loading from a YAML file and environment variables.</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    Manages configuration for the trading bot, loading from a YAML file\n    and environment variables.\n    \"\"\"\n\n    # Private Keys and API Credentials (from .env)\n    CROWDCENT_API_KEY: str | None = None\n    HYPERLIQUID_PRIVATE_KEY: str | None = (\n        None  # Private key for signing (owner or approved agent wallet)\n    )\n\n    # Environment\n    is_testnet: bool = False\n    base_url: str = \"https://api.hyperliquid.xyz\"\n\n    # Profiles (addresses in config; secrets remain in env)\n    active_profile: str | None = \"default\"\n    profiles: dict[str, Any] = field(default_factory=dict)\n\n    # Resolved addresses from active profile (owner/vault)\n    HYPERLIQUID_ADDRESS: str | None = None\n    HYPERLIQUID_VAULT_ADDRESS: str | None = None\n\n    # Nested Configs\n    data: DataSourceConfig = field(default_factory=DataSourceConfig)\n    portfolio: PortfolioConfig = field(default_factory=PortfolioConfig)\n    execution: ExecutionConfig = field(default_factory=ExecutionConfig)\n\n    def __post_init__(self):\n        \"\"\"Load environment variables and YAML config after initialization.\"\"\"\n        self._load_env_vars()\n        self._load_yaml_config()\n        self._resolve_profile()  # Must come AFTER loading YAML (which loads profiles)\n        self._set_base_url()\n        self._validate()\n\n    def _load_env_vars(self):\n        \"\"\"Load secrets-only from .env; addresses come from YAML/profiles.\"\"\"\n        load_dotenv()\n        self.CROWDCENT_API_KEY = os.getenv(\"CROWDCENT_API_KEY\")\n        # Don't load private key here - will be resolved based on profile's signer_env\n\n    def _load_yaml_config(self, config_path: str | None = None):\n        \"\"\"Loads and overrides config from a YAML file.\"\"\"\n        path = config_path or DEFAULT_CONFIG_PATH\n        if os.path.exists(path):\n            with open(path) as f:\n                yaml_config: dict[str, Any] = yaml.safe_load(f) or {}\n\n            for key, value in yaml_config.items():\n                if hasattr(self, key):\n                    # Handle nested dataclasses\n                    if isinstance(value, dict) and is_dataclass(getattr(self, key)):\n                        nested_config_obj = getattr(self, key)\n                        for nested_key, nested_value in value.items():\n                            if hasattr(nested_config_obj, nested_key):\n                                # Handle double nested dataclasses\n                                if isinstance(nested_value, dict) and is_dataclass(\n                                    getattr(nested_config_obj, nested_key)\n                                ):\n                                    nested_dataclass = getattr(\n                                        nested_config_obj, nested_key\n                                    )\n                                    for deep_key, deep_value in nested_value.items():\n                                        if hasattr(nested_dataclass, deep_key):\n                                            setattr(\n                                                nested_dataclass, deep_key, deep_value\n                                            )\n                                else:\n                                    setattr(nested_config_obj, nested_key, nested_value)\n                    else:\n                        # Direct assignment for non-dataclass fields (like profiles dict)\n                        setattr(self, key, value)\n\n    def _set_base_url(self):\n        \"\"\"Sets the base URL based on the is_testnet flag.\"\"\"\n        if self.is_testnet:\n            self.base_url = \"https://api.hyperliquid-testnet.xyz\"\n\n    def _resolve_profile(self):\n        \"\"\"Resolve owner/vault addresses and signer key from the active profile.\"\"\"\n        # If no profiles defined, skip resolution\n        if not self.profiles:\n            return\n\n        active = self.active_profile or \"default\"\n        profile = self.profiles.get(active, {})\n\n        # Extract owner and vault from profile\n        owner = profile.get(\"owner\")\n        vault = profile.get(\"vault\")\n\n        # Set addresses (owner is required, vault is optional)\n        self.HYPERLIQUID_ADDRESS = owner\n        self.HYPERLIQUID_VAULT_ADDRESS = vault\n\n        # Resolve signer key from environment based on profile's signer_env\n        signer_env = profile.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n        self.HYPERLIQUID_PRIVATE_KEY = os.getenv(signer_env)\n\n        # Fallback to default env var if custom signer_env not found\n        if not self.HYPERLIQUID_PRIVATE_KEY and signer_env != \"HYPERLIQUID_PRIVATE_KEY\":\n            self.HYPERLIQUID_PRIVATE_KEY = os.getenv(\"HYPERLIQUID_PRIVATE_KEY\")\n\n    def refresh_runtime(self):\n        \"\"\"Refresh runtime configuration after changes (e.g., CLI overrides).\"\"\"\n        self._set_base_url()\n        self._resolve_profile()\n        self._validate()\n\n    def _validate(self):\n        \"\"\"Validate that required configuration is present.\n\n        Note: This is lenient during initial module load to allow CLI commands\n        like 'profile list' to work even without complete setup.\n        \"\"\"\n        # Check if active profile exists\n        if self.profiles and self.active_profile:\n            if self.active_profile not in self.profiles:\n                available = \", \".join(sorted(self.profiles.keys()))\n                raise ValueError(\n                    f\"Active profile '{self.active_profile}' not found. Available profiles: {available}\"\n                )\n\n        # Don't validate addresses/keys during module import - let individual commands handle it\n        # This allows 'profile list', 'config', etc to work without full setup\n\n    def validate_for_trading(self):\n        \"\"\"Strict validation for trading operations.\n\n        Call this before any trading operations to ensure all required config is present.\n        \"\"\"\n        # Validate we have required addresses from profile\n        if not self.HYPERLIQUID_ADDRESS and not self.HYPERLIQUID_VAULT_ADDRESS:\n            raise ValueError(\n                \"Profile must specify 'owner' or 'vault' address in cc-liquid-config.yaml\"\n            )\n\n        # Validate we have a private key\n        if not self.HYPERLIQUID_PRIVATE_KEY:\n            # Better error message showing which env var is expected\n            signer_env = \"HYPERLIQUID_PRIVATE_KEY\"\n            if self.profiles and self.active_profile:\n                profile = self.profiles.get(self.active_profile, {})\n                signer_env = profile.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n            raise ValueError(\n                f\"Private key not found. Set '{signer_env}' in your .env file.\"\n            )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dictionary representation of the config.\"\"\"\n        portfolio_dict = self.portfolio.__dict__.copy()\n        # Convert nested dataclass to dict\n        if hasattr(self.portfolio, \"rebalancing\"):\n            portfolio_dict[\"rebalancing\"] = self.portfolio.rebalancing.__dict__\n\n        # Profile summary (non-secret)\n        active_profile = self.active_profile\n        prof = self.profiles.get(active_profile) if self.profiles else {}\n        signer_env_name = (\n            prof.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n            if prof\n            else \"HYPERLIQUID_PRIVATE_KEY\"\n        )\n        profile_dict = {\n            \"active\": active_profile,\n            \"owner\": self.HYPERLIQUID_ADDRESS,\n            \"vault\": self.HYPERLIQUID_VAULT_ADDRESS,\n            \"signer_env\": signer_env_name,\n        }\n\n        return {\n            \"is_testnet\": self.is_testnet,\n            \"profile\": profile_dict,\n            \"data\": self.data.__dict__,\n            \"portfolio\": portfolio_dict,\n            \"execution\": self.execution.__dict__,\n        }\n</code></pre>"},{"location":"api/python/#cc_liquid.config.Config.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Load environment variables and YAML config after initialization.</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Load environment variables and YAML config after initialization.\"\"\"\n    self._load_env_vars()\n    self._load_yaml_config()\n    self._resolve_profile()  # Must come AFTER loading YAML (which loads profiles)\n    self._set_base_url()\n    self._validate()\n</code></pre>"},{"location":"api/python/#cc_liquid.config.Config.refresh_runtime","title":"<code>refresh_runtime()</code>","text":"<p>Refresh runtime configuration after changes (e.g., CLI overrides).</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>def refresh_runtime(self):\n    \"\"\"Refresh runtime configuration after changes (e.g., CLI overrides).\"\"\"\n    self._set_base_url()\n    self._resolve_profile()\n    self._validate()\n</code></pre>"},{"location":"api/python/#cc_liquid.config.Config.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a dictionary representation of the config.</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dictionary representation of the config.\"\"\"\n    portfolio_dict = self.portfolio.__dict__.copy()\n    # Convert nested dataclass to dict\n    if hasattr(self.portfolio, \"rebalancing\"):\n        portfolio_dict[\"rebalancing\"] = self.portfolio.rebalancing.__dict__\n\n    # Profile summary (non-secret)\n    active_profile = self.active_profile\n    prof = self.profiles.get(active_profile) if self.profiles else {}\n    signer_env_name = (\n        prof.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n        if prof\n        else \"HYPERLIQUID_PRIVATE_KEY\"\n    )\n    profile_dict = {\n        \"active\": active_profile,\n        \"owner\": self.HYPERLIQUID_ADDRESS,\n        \"vault\": self.HYPERLIQUID_VAULT_ADDRESS,\n        \"signer_env\": signer_env_name,\n    }\n\n    return {\n        \"is_testnet\": self.is_testnet,\n        \"profile\": profile_dict,\n        \"data\": self.data.__dict__,\n        \"portfolio\": portfolio_dict,\n        \"execution\": self.execution.__dict__,\n    }\n</code></pre>"},{"location":"api/python/#cc_liquid.config.Config.validate_for_trading","title":"<code>validate_for_trading()</code>","text":"<p>Strict validation for trading operations.</p> <p>Call this before any trading operations to ensure all required config is present.</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>def validate_for_trading(self):\n    \"\"\"Strict validation for trading operations.\n\n    Call this before any trading operations to ensure all required config is present.\n    \"\"\"\n    # Validate we have required addresses from profile\n    if not self.HYPERLIQUID_ADDRESS and not self.HYPERLIQUID_VAULT_ADDRESS:\n        raise ValueError(\n            \"Profile must specify 'owner' or 'vault' address in cc-liquid-config.yaml\"\n        )\n\n    # Validate we have a private key\n    if not self.HYPERLIQUID_PRIVATE_KEY:\n        # Better error message showing which env var is expected\n        signer_env = \"HYPERLIQUID_PRIVATE_KEY\"\n        if self.profiles and self.active_profile:\n            profile = self.profiles.get(self.active_profile, {})\n            signer_env = profile.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n        raise ValueError(\n            f\"Private key not found. Set '{signer_env}' in your .env file.\"\n        )\n</code></pre>"},{"location":"api/python/#data-loading","title":"Data loading","text":""},{"location":"api/python/#cc_liquid.data_loader.DataLoader","title":"<code>DataLoader</code>","text":"<p>Factory for creating data sources.</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>class DataLoader:\n    \"\"\"Factory for creating data sources.\"\"\"\n\n    @staticmethod\n    def from_file(path: str, date_col: str, id_col: str, pred_col: str) -&gt; pl.DataFrame:\n        \"\"\"Create a file data source and load data.\"\"\"\n        return FileDataSource(\n            path,\n            date_column=date_col,\n            asset_id_column=id_col,\n            prediction_column=pred_col,\n        ).load()\n\n    @staticmethod\n    def from_dataframe(\n        df: pl.DataFrame, date_col: str, id_col: str, pred_col: str\n    ) -&gt; pl.DataFrame:\n        \"\"\"Create a DataFrame data source and load data.\"\"\"\n        return DataFrameDataSource(\n            df,\n            date_column=date_col,\n            asset_id_column=id_col,\n            prediction_column=pred_col,\n        ).load()\n\n    @staticmethod\n    def from_crowdcent_api(\n        api_key: str | None = None,\n        challenge_slug: str = \"hyperliquid-ranking\",\n        download_path: str | None = None,\n        date_col: str = \"release_date\",\n        id_col: str = \"id\",\n        pred_col: str = \"pred_10d\",\n    ) -&gt; pl.DataFrame:\n        \"\"\"\n        Download and load the CrowdCent meta model.\n\n        Args:\n            api_key: CrowdCent API key (if None, will try to load from env)\n            challenge_slug: The challenge to download data for\n            download_path: Optional path to save the downloaded file\n            date_col: Date column name in the meta model\n            id_col: Asset ID column name in the meta model\n            pred_col: Prediction column name to use from the meta model\n\n        Returns:\n            Polars DataFrame with original column names\n        \"\"\"\n        from crowdcent_challenge import ChallengeClient\n\n        if api_key is None:\n            import os\n\n            api_key = os.getenv(\"CROWDCENT_API_KEY\")\n            if not api_key:\n                raise ValueError(\"CROWDCENT_API_KEY not found in environment variables\")\n\n        client = ChallengeClient(challenge_slug=challenge_slug, api_key=api_key)\n\n        if download_path is None:\n            download_path = \"predictions.parquet\"\n\n        client.download_meta_model(download_path)\n\n        return DataLoader.from_file(\n            path=download_path, date_col=date_col, id_col=id_col, pred_col=pred_col\n        )\n\n    @staticmethod\n    def from_numerai_api(\n        download_path: str | None = None,\n        date_col: str = \"date\",\n        id_col: str = \"symbol\",\n        pred_col: str = \"meta_model\",\n    ) -&gt; pl.DataFrame:\n        \"\"\"\n        Download and load the Numerai crypto meta model.\n\n        Args:\n            download_path: Optional path to save the downloaded file\n            date_col: Date column name in the meta model\n            id_col: Asset ID/symbol column name in the meta model\n            pred_col: Prediction column name to use from the meta model\n\n        Returns:\n            Polars DataFrame with original column names\n        \"\"\"\n        try:\n            from numerapi import CryptoAPI\n        except ImportError:\n            raise ImportError(\n                \"numerapi is required. Install with: uv add cc-liquid[numerai]\"\n            )\n\n        api = CryptoAPI()\n\n        if download_path is None:\n            download_path = \"predictions.parquet\"\n\n        api.download_dataset(\"v1.0/historical_meta_models.parquet\", download_path)\n\n        return DataLoader.from_file(\n            path=download_path, date_col=date_col, id_col=id_col, pred_col=pred_col\n        )\n</code></pre>"},{"location":"api/python/#cc_liquid.data_loader.DataLoader.from_crowdcent_api","title":"<code>from_crowdcent_api(api_key=None, challenge_slug='hyperliquid-ranking', download_path=None, date_col='release_date', id_col='id', pred_col='pred_10d')</code>  <code>staticmethod</code>","text":"<p>Download and load the CrowdCent meta model.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str | None</code> <p>CrowdCent API key (if None, will try to load from env)</p> <code>None</code> <code>challenge_slug</code> <code>str</code> <p>The challenge to download data for</p> <code>'hyperliquid-ranking'</code> <code>download_path</code> <code>str | None</code> <p>Optional path to save the downloaded file</p> <code>None</code> <code>date_col</code> <code>str</code> <p>Date column name in the meta model</p> <code>'release_date'</code> <code>id_col</code> <code>str</code> <p>Asset ID column name in the meta model</p> <code>'id'</code> <code>pred_col</code> <code>str</code> <p>Prediction column name to use from the meta model</p> <code>'pred_10d'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Polars DataFrame with original column names</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>@staticmethod\ndef from_crowdcent_api(\n    api_key: str | None = None,\n    challenge_slug: str = \"hyperliquid-ranking\",\n    download_path: str | None = None,\n    date_col: str = \"release_date\",\n    id_col: str = \"id\",\n    pred_col: str = \"pred_10d\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Download and load the CrowdCent meta model.\n\n    Args:\n        api_key: CrowdCent API key (if None, will try to load from env)\n        challenge_slug: The challenge to download data for\n        download_path: Optional path to save the downloaded file\n        date_col: Date column name in the meta model\n        id_col: Asset ID column name in the meta model\n        pred_col: Prediction column name to use from the meta model\n\n    Returns:\n        Polars DataFrame with original column names\n    \"\"\"\n    from crowdcent_challenge import ChallengeClient\n\n    if api_key is None:\n        import os\n\n        api_key = os.getenv(\"CROWDCENT_API_KEY\")\n        if not api_key:\n            raise ValueError(\"CROWDCENT_API_KEY not found in environment variables\")\n\n    client = ChallengeClient(challenge_slug=challenge_slug, api_key=api_key)\n\n    if download_path is None:\n        download_path = \"predictions.parquet\"\n\n    client.download_meta_model(download_path)\n\n    return DataLoader.from_file(\n        path=download_path, date_col=date_col, id_col=id_col, pred_col=pred_col\n    )\n</code></pre>"},{"location":"api/python/#cc_liquid.data_loader.DataLoader.from_dataframe","title":"<code>from_dataframe(df, date_col, id_col, pred_col)</code>  <code>staticmethod</code>","text":"<p>Create a DataFrame data source and load data.</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>@staticmethod\ndef from_dataframe(\n    df: pl.DataFrame, date_col: str, id_col: str, pred_col: str\n) -&gt; pl.DataFrame:\n    \"\"\"Create a DataFrame data source and load data.\"\"\"\n    return DataFrameDataSource(\n        df,\n        date_column=date_col,\n        asset_id_column=id_col,\n        prediction_column=pred_col,\n    ).load()\n</code></pre>"},{"location":"api/python/#cc_liquid.data_loader.DataLoader.from_file","title":"<code>from_file(path, date_col, id_col, pred_col)</code>  <code>staticmethod</code>","text":"<p>Create a file data source and load data.</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>@staticmethod\ndef from_file(path: str, date_col: str, id_col: str, pred_col: str) -&gt; pl.DataFrame:\n    \"\"\"Create a file data source and load data.\"\"\"\n    return FileDataSource(\n        path,\n        date_column=date_col,\n        asset_id_column=id_col,\n        prediction_column=pred_col,\n    ).load()\n</code></pre>"},{"location":"api/python/#cc_liquid.data_loader.DataLoader.from_numerai_api","title":"<code>from_numerai_api(download_path=None, date_col='date', id_col='symbol', pred_col='meta_model')</code>  <code>staticmethod</code>","text":"<p>Download and load the Numerai crypto meta model.</p> <p>Parameters:</p> Name Type Description Default <code>download_path</code> <code>str | None</code> <p>Optional path to save the downloaded file</p> <code>None</code> <code>date_col</code> <code>str</code> <p>Date column name in the meta model</p> <code>'date'</code> <code>id_col</code> <code>str</code> <p>Asset ID/symbol column name in the meta model</p> <code>'symbol'</code> <code>pred_col</code> <code>str</code> <p>Prediction column name to use from the meta model</p> <code>'meta_model'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Polars DataFrame with original column names</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>@staticmethod\ndef from_numerai_api(\n    download_path: str | None = None,\n    date_col: str = \"date\",\n    id_col: str = \"symbol\",\n    pred_col: str = \"meta_model\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Download and load the Numerai crypto meta model.\n\n    Args:\n        download_path: Optional path to save the downloaded file\n        date_col: Date column name in the meta model\n        id_col: Asset ID/symbol column name in the meta model\n        pred_col: Prediction column name to use from the meta model\n\n    Returns:\n        Polars DataFrame with original column names\n    \"\"\"\n    try:\n        from numerapi import CryptoAPI\n    except ImportError:\n        raise ImportError(\n            \"numerapi is required. Install with: uv add cc-liquid[numerai]\"\n        )\n\n    api = CryptoAPI()\n\n    if download_path is None:\n        download_path = \"predictions.parquet\"\n\n    api.download_dataset(\"v1.0/historical_meta_models.parquet\", download_path)\n\n    return DataLoader.from_file(\n        path=download_path, date_col=date_col, id_col=id_col, pred_col=pred_col\n    )\n</code></pre>"},{"location":"api/python/#trading-logic","title":"Trading logic","text":""},{"location":"api/python/#cc_liquid.trader.CCLiquid","title":"<code>CCLiquid</code>","text":"<p>Handles all interactions with the Hyperliquid exchange.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>class CCLiquid:\n    \"\"\"\n    Handles all interactions with the Hyperliquid exchange.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Config,\n        callbacks: CCLiquidCallbacks | None = None,\n        skip_ws: bool = True,\n    ):\n        self.config = config\n        self.callbacks = callbacks or NoOpCallbacks()\n\n        # Validate config for trading operations\n        self.config.validate_for_trading()\n\n        self.account: LocalAccount = self._get_account()\n        self.exchange = Exchange(\n            self.account,\n            self.config.base_url,\n            vault_address=(self.config.HYPERLIQUID_VAULT_ADDRESS or None),\n            account_address=self.config.HYPERLIQUID_ADDRESS,\n        )\n        self.info = Info(self.config.base_url, skip_ws=skip_ws)\n        self.logger = logging.getLogger(__name__)\n        # Lazy-loaded map of coin -&gt; szDecimals from Info.meta()[\"universe\"].\n        # Perps only: Hyperliquid perps use max 6 decimals for price rules.\n        self._coin_to_sz_decimals: dict[str, int] | None = None\n\n    def _get_account(self) -&gt; LocalAccount:\n        \"\"\"Creates an eth_account LocalAccount object from the private key.\"\"\"\n        from eth_account import Account\n\n        return Account.from_key(self.config.HYPERLIQUID_PRIVATE_KEY)\n\n    def get_user_state(self) -&gt; dict[str, Any]:\n        \"\"\"Retrieves the current state of the user's account.\"\"\"\n        # Always query Info using the portfolio owner: vault (if set) or master address.\n        # Never use the agent/signer address for Info, as it has no balances.\n        owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n        if not owner:\n            raise ValueError(\n                \"Missing portfolio owner. Set HYPERLIQUID_VAULT_ADDRESS or HYPERLIQUID_ADDRESS.\"\n            )\n        return self.info.user_state(owner)\n\n    def get_positions(self) -&gt; dict[str, Any]:\n        \"\"\"Retrieves the user's open positions as a dict.\"\"\"\n        user_state = self.get_user_state()\n        positions = {}\n        for position_data in user_state.get(\"assetPositions\", []):\n            position = position_data.get(\"position\", {})\n            if float(position.get(\"szi\", 0)) != 0:\n                positions[position[\"coin\"]] = position\n        return positions\n\n    def get_account_value(self) -&gt; float:\n        \"\"\"Retrieves the total account value in USD.\"\"\"\n        user_state = self.get_user_state()\n        return float(user_state[\"marginSummary\"][\"accountValue\"])\n\n    def get_portfolio_info(self) -&gt; PortfolioInfo:\n        \"\"\"Get complete portfolio information as structured data.\"\"\"\n        try:\n            user_state = self.get_user_state()\n        except Exception as e:\n            self.logger.warning(f\"Could not get user state: {e}\")\n            # Return empty portfolio if we can't connect\n            return PortfolioInfo(\n                account=AccountInfo(\n                    account_value=0,\n                    total_position_value=0,\n                    margin_used=0,\n                    free_collateral=0,\n                    cash_balance=0,\n                    withdrawable=0,\n                    current_leverage=0,\n                ),\n                positions=[],\n            )\n\n        margin_summary = user_state.get(\"marginSummary\", {}) if user_state else {}\n        all_mids = self.info.all_mids() if user_state else {}\n\n        # Build account info\n        account_info = AccountInfo(\n            account_value=float(margin_summary.get(\"accountValue\", 0)),\n            total_position_value=float(margin_summary.get(\"totalNtlPos\", 0)),\n            margin_used=float(margin_summary.get(\"totalMarginUsed\", 0)),\n            free_collateral=float(margin_summary.get(\"accountValue\", 0))\n            - float(margin_summary.get(\"totalMarginUsed\", 0)),\n            cash_balance=float(margin_summary.get(\"totalRawUsd\", 0)),\n            withdrawable=float(user_state.get(\"withdrawable\", 0)),\n            current_leverage=float(margin_summary.get(\"totalNtlPos\", 0))\n            / float(margin_summary.get(\"accountValue\", 1))\n            if float(margin_summary.get(\"accountValue\", 0)) &gt; 0\n            else 0,\n            raw_margin_summary=margin_summary,\n        )\n\n        # Add cross margin info if available\n        cross_margin = user_state.get(\"crossMarginSummary\")\n        if cross_margin:\n            account_info.cross_leverage = (\n                float(cross_margin.get(\"accountValue\", 0))\n                / float(margin_summary.get(\"accountValue\", 1))\n                if float(margin_summary.get(\"accountValue\", 0)) &gt; 0\n                else 0\n            )\n            account_info.cross_margin_used = float(\n                cross_margin.get(\"totalMarginUsed\", 0)\n            )\n            account_info.cross_maintenance_margin = float(\n                cross_margin.get(\"totalMaintenanceMargin\", 0)\n            )\n            account_info.raw_cross_margin_summary = cross_margin\n\n        # Build positions list\n        positions = []\n        for position_data in user_state.get(\"assetPositions\", []):\n            pos = position_data.get(\"position\", {})\n            size = float(pos.get(\"szi\", 0))\n\n            if size == 0:\n                continue\n\n            coin = pos[\"coin\"]\n            entry_px = float(pos.get(\"entryPx\", 0))\n            mark_px = float(all_mids.get(coin, entry_px))\n            position_value = abs(size * mark_px)\n\n            # Calculate unrealized PnL\n            if size &gt; 0:\n                unrealized_pnl = (mark_px - entry_px) * size\n                side = \"LONG\"\n            else:\n                unrealized_pnl = (entry_px - mark_px) * abs(size)\n                side = \"SHORT\"\n\n            return_pct = (\n                (unrealized_pnl / (abs(size) * entry_px) * 100) if entry_px &gt; 0 else 0\n            )\n\n            positions.append(\n                Position(\n                    coin=coin,\n                    side=side,\n                    size=abs(size),\n                    entry_price=entry_px,\n                    mark_price=mark_px,\n                    value=position_value,\n                    unrealized_pnl=unrealized_pnl,\n                    return_pct=return_pct,\n                    liquidation_price=float(pos[\"liquidationPx\"])\n                    if \"liquidationPx\" in pos and pos[\"liquidationPx\"] is not None\n                    else None,\n                    margin_used=float(pos[\"marginUsed\"])\n                    if \"marginUsed\" in pos and pos[\"marginUsed\"] is not None\n                    else None,\n                )\n            )\n\n        return PortfolioInfo(account=account_info, positions=positions)\n\n    # --- Rounding helpers (Perps only) ---\n    def _load_sz_decimals_map(self, force_refresh: bool = False) -&gt; dict[str, int]:\n        \"\"\"Load and cache coin -&gt; szDecimals from exchange meta.\n\n        Per Hyperliquid rounding guidance for orders, sizes must be rounded to a\n        coin-specific number of decimals (szDecimals). We cache from `info.meta()`\n        and refresh on demand.\n        \"\"\"\n        if self._coin_to_sz_decimals is None or force_refresh:\n            try:\n                universe = self.info.meta().get(\"universe\", [])\n                self._coin_to_sz_decimals = {\n                    asset.get(\"name\"): int(asset.get(\"szDecimals\", 2))\n                    for asset in universe\n                    if asset.get(\"name\") and not asset.get(\"isDelisted\", False)\n                }\n            except Exception as e:\n                self.logger.warning(f\"Failed to load szDecimals map: {e}\")\n                self._coin_to_sz_decimals = {}\n        return self._coin_to_sz_decimals\n\n    def _get_sz_decimals(self, coin: str) -&gt; int | None:\n        \"\"\"Return szDecimals for the given coin, refreshing meta once if needed.\"\"\"\n        sz_map = self._load_sz_decimals_map()\n        if coin not in sz_map:\n            sz_map = self._load_sz_decimals_map(force_refresh=True)\n        return sz_map.get(coin)\n\n    def _round_size(self, coin: str, size: float) -&gt; tuple[float, int] | None:\n        \"\"\"Round size per coin's szDecimals.\n\n        Returns (rounded_size, sz_decimals) or None if szDecimals are unknown.\n        \"\"\"\n        sz_decimals = self._get_sz_decimals(coin)\n        if sz_decimals is None:\n            return None\n        return round(size, sz_decimals), sz_decimals\n\n    def _round_price_perp(self, coin: str, px: float) -&gt; float:\n        \"\"\"Round price according to Hyperliquid perp rules (not used for market orders).\n\n        Rules (per Hyperliquid):\n        - If px &gt; 100_000: round to integer.\n        - Else: round to 5 significant figures and at most (6 - szDecimals) decimals.\n        Reference: Hyperliquid SDK example rounding: see rounding.py\n        \"\"\"\n        if px &gt; 100_000:\n            return round(px)\n        sz_decimals = self._get_sz_decimals(coin)\n        # If unknown, still limit to 5 significant figures as a safe default.\n        if sz_decimals is None:\n            return float(f\"{px:.5g}\")\n        max_decimals = 6  # perps\n        return round(float(f\"{px:.5g}\"), max_decimals - sz_decimals)\n\n    def plan_rebalance(self, predictions: pl.DataFrame | None = None) -&gt; dict:\n        \"\"\"Compute a rebalancing plan without executing orders.\"\"\"\n        # Load predictions if not provided\n        if predictions is None:\n            self.callbacks.info(\"Loading predictions...\")\n            predictions = self._load_predictions()\n\n            if predictions is None or predictions.is_empty():\n                self.callbacks.error(\"No predictions available, cannot rebalance\")\n                return {\n                    \"target_positions\": {},\n                    \"trades\": [],\n                    \"skipped_trades\": [],\n                    \"account_value\": 0.0,\n                    \"leverage\": self.config.portfolio.target_leverage,\n                }\n\n            # Display prediction info\n            unique_assets = predictions[self.config.data.asset_id_column].n_unique()\n            latest_data = predictions[self.config.data.date_column].max()\n            self.callbacks.info(\n                f\"Loaded predictions for {unique_assets} assets (latest: {latest_data})\"\n            )\n\n        # Asset Selection, Position Calculation, and Trade Generation\n        target_positions = self._get_target_positions(predictions)\n        current_positions = self.get_positions()\n        trades, skipped_trades = self._calculate_trades(\n            target_positions, current_positions\n        )\n\n        # Build plan (including skipped trades)\n        account_value = self.get_account_value()\n        leverage = self.config.portfolio.target_leverage\n        return {\n            \"target_positions\": target_positions,\n            \"trades\": trades,\n            \"skipped_trades\": skipped_trades,\n            \"account_value\": account_value,\n            \"leverage\": leverage,\n        }\n\n    def execute_plan(self, plan: dict) -&gt; dict:\n        \"\"\"Execute a precomputed plan, returning structured results.\"\"\"\n        trades: list[dict] = plan.get(\"trades\", [])\n        if not trades:\n            # Nothing to do\n            return {\"successful_trades\": [], \"all_trades\": trades}\n\n        # Prioritize leverage reduction: execute closes/reductions (and flips) before opens\n        trades = self._sort_trades_for_leverage_reduction(trades)\n\n        self.callbacks.info(f\"Starting execution of {len(trades)} trades...\")\n        successful_trades = self._execute_trades(trades)\n        return {\"successful_trades\": successful_trades, \"all_trades\": trades}\n\n    def plan_close_all_positions(self, *, force: bool = False) -&gt; dict:\n        \"\"\"Plan to close all open positions (return to cash) without executing orders.\"\"\"\n        current_positions = self.get_positions()\n\n        if not current_positions:\n            self.callbacks.info(\"No open positions to close.\")\n            return {\n                \"target_positions\": {},\n                \"trades\": [],\n                \"skipped_trades\": [],\n                \"account_value\": self.get_account_value(),\n                \"leverage\": self.config.portfolio.target_leverage,\n            }\n\n        self.callbacks.info(\"Closing all positions to return to cash...\")\n\n        # Create target positions of 0 for all current positions\n        target_positions = {coin: 0 for coin in current_positions.keys()}\n        trades, skipped_trades = self._calculate_trades(\n            target_positions, current_positions, force=force\n        )\n\n        account_value = self.get_account_value()\n        leverage = self.config.portfolio.target_leverage\n        return {\n            \"target_positions\": target_positions,\n            \"trades\": trades,\n            \"skipped_trades\": skipped_trades,\n            \"account_value\": account_value,\n            \"leverage\": leverage,\n        }\n\n    def _get_target_positions(self, predictions: pl.DataFrame) -&gt; dict[str, float]:\n        \"\"\"Calculates the target notional value for each position using equal weighting.\"\"\"\n        latest_predictions = self._get_latest_predictions(predictions)\n        long_assets = self._select_assets(latest_predictions, descending=True)\n        short_assets = self._select_assets(latest_predictions, descending=False)\n\n        account_value = self.get_account_value()\n        total_positions = (\n            self.config.portfolio.num_long + self.config.portfolio.num_short\n        )\n\n        # When using leverage, we can allocate more notional value per position\n        # This effectively creates leveraged positions by sizing them larger than account equity\n        target_leverage = self.config.portfolio.target_leverage\n        position_value = (account_value * target_leverage) / total_positions\n\n        # Log the calculation for transparency\n        self.callbacks.info(\n            f\"Position sizing: ${account_value:.2f} \u00d7 {target_leverage}x leverage \"\n            f\"\u00f7 {total_positions} positions = ${position_value:.2f} per position\"\n        )\n\n        # Warn if position sizes will be too small\n        min_position_value = self.config.execution.min_trade_value\n        if position_value &lt; min_position_value:\n            msg = \"Warning: Position size too small!\\n\"\n            msg += f\"   Account value: ${account_value:.2f}\\n\"\n            if target_leverage &gt; 1.0:\n                msg += f\"   With {target_leverage}x leverage: ${account_value * target_leverage:.2f} total exposure\\n\"\n            msg += f\"   Divided by {total_positions} positions = ${position_value:.2f} per position\\n\"\n            msg += f\"   Minimum required: ${min_position_value}\\n\\n\"\n            msg += \"   Solutions:\\n\"\n            msg += f\"   \u2022 Reduce positions (currently {self.config.portfolio.num_long} long + {self.config.portfolio.num_short} short)\\n\"\n            msg += \"   \u2022 Increase account value\\n\"\n            if target_leverage &lt; 5.0:\n                msg += f\"   \u2022 Increase leverage (currently {target_leverage}x)\\n\"\n            self.callbacks.warn(msg)\n\n        target_positions = {}\n        for asset in long_assets:\n            target_positions[asset] = position_value\n        for asset in short_assets:\n            target_positions[asset] = -position_value\n\n        return target_positions\n\n    def _get_latest_predictions(self, predictions: pl.DataFrame) -&gt; pl.DataFrame:\n        \"\"\"Filters for the latest predictions for each asset by date.\"\"\"\n        return (\n            predictions.sort(self.config.data.date_column, descending=True)\n            .group_by(self.config.data.asset_id_column)\n            .first()\n        )\n\n    def _select_assets(self, predictions: pl.DataFrame, descending: bool) -&gt; list[str]:\n        \"\"\"Selects top or bottom N assets based on prediction score,\n        filtered to only assets currently listed on Hyperliquid.\"\"\"\n\n        # Use listed assets from /info meta\n        universe = self.info.meta()[\"universe\"]\n        available_assets = {\n            p[\"name\"] for p in universe if not p.get(\"isDelisted\", False)\n        }\n\n        # Filter predictions to only tradeable assets\n        tradeable_predictions = predictions.filter(\n            pl.col(self.config.data.asset_id_column).is_in(available_assets)\n        )\n\n        if tradeable_predictions.height == 0:\n            self.logger.warning(\"No predictions match Hyperliquid tradeable assets!\")\n            self.callbacks.error(\n                \"Error: No predictions match Hyperliquid tradeable assets!\"\n            )\n            self.callbacks.info(\n                f\"Available on Hyperliquid: {sorted(list(available_assets)[:10])}{'...' if len(available_assets) &gt; 10 else ''}\"\n            )\n            prediction_assets = (\n                predictions[self.config.data.asset_id_column].unique().to_list()\n            )\n            self.callbacks.info(\n                f\"In predictions: {sorted(prediction_assets[:10])}{'...' if len(prediction_assets) &gt; 10 else ''}\"\n            )\n            return []\n\n        # Select from filtered set\n        num_assets = (\n            self.config.portfolio.num_long\n            if descending\n            else self.config.portfolio.num_short\n        )\n\n        # Warn if we don't have enough tradeable assets\n        if tradeable_predictions.height &lt; num_assets:\n            self.callbacks.warn(\n                f\"Warning: Only {tradeable_predictions.height} tradeable assets available, requested {num_assets}\"\n            )\n            self.callbacks.info(\n                f\"Will use all {tradeable_predictions.height} available assets\"\n            )\n\n        selected = (\n            tradeable_predictions.sort(\n                self.config.data.prediction_column, descending=descending\n            )\n            .head(num_assets)[self.config.data.asset_id_column]\n            .to_list()\n        )\n\n        return selected\n\n    def _calculate_trades(\n        self,\n        target_positions: dict[str, float],\n        current_positions: dict[str, Any],\n        *,\n        force: bool = False,\n    ) -&gt; tuple[list[dict[str, Any]], list[dict[str, Any]]]:\n        \"\"\"Calculates the trades required to reach the target portfolio using market orders.\n\n        Returns:\n            (executable_trades, skipped_trades) - trades that can be executed and those below minimum\n        \"\"\"\n        trades = []\n        skipped_trades = []  # Track trades we can't execute\n        all_mids = self.info.all_mids()\n\n        all_assets = set(target_positions.keys()) | set(current_positions.keys())\n\n        for asset in all_assets:\n            target_value = target_positions.get(asset, 0)\n\n            # Get current position details\n            current_position = current_positions.get(asset, {})\n            current_size = float(current_position.get(\"szi\", 0))\n\n            # Ensure we have a mid price; otherwise skip\n            if asset not in all_mids:\n                skipped_trades.append(\n                    {\n                        \"coin\": asset,\n                        \"target_value\": target_value,\n                        \"skipped\": True,\n                        \"skip_reason\": \"No mid price available\",\n                    }\n                )\n                continue\n\n            price = float(all_mids[asset])\n\n            # Calculate current value with proper sign\n            # szi is positive for long, negative for short\n            current_value = current_size * price\n\n            # Calculate the value delta we need to achieve\n            delta_value = target_value - current_value\n\n            # Determine trade direction\n            # If delta_value &gt; 0, we need to buy (increase position or reduce short)\n            # If delta_value &lt; 0, we need to sell (decrease position or increase short)\n            is_buy = delta_value &gt; 0\n            size = abs(delta_value) / price\n\n            # Round the size using szDecimals from meta (perps only)\n            coin = asset\n            rounded = self._round_size(coin, size)\n            if rounded is None:\n                skipped_trades.append(\n                    {\n                        \"coin\": asset,\n                        \"target_value\": target_value,\n                        \"skipped\": True,\n                        \"skip_reason\": \"Unknown szDecimals (meta)\",\n                    }\n                )\n                continue\n            size, sz_decimals = rounded\n\n            # If rounding collapses to zero, skip\n            if size == 0:\n                skipped_trades.append(\n                    {\n                        \"coin\": asset,\n                        \"target_value\": target_value,\n                        \"skipped\": True,\n                        \"skip_reason\": f\"Rounded size is 0 at {sz_decimals} dp\",\n                    }\n                )\n                continue\n\n            # Check if trade is below minimum value threshold\n            min_trade_value = self.config.execution.min_trade_value\n            # Classify the trade type for clearer downstream handling\n            # Types: open, close, reduce, increase, flip\n            trade_type: str\n            if current_value == 0:\n                trade_type = \"open\" if target_value != 0 else \"increase\"\n            elif target_value == 0:\n                trade_type = \"close\"\n            else:\n                same_sign = (current_value &gt; 0 and target_value &gt; 0) or (\n                    current_value &lt; 0 and target_value &lt; 0\n                )\n                if same_sign:\n                    trade_type = (\n                        \"reduce\"\n                        if abs(target_value) &lt; abs(current_value)\n                        else \"increase\"\n                    )\n                else:\n                    trade_type = \"flip\"\n\n            trade_data = {\n                \"coin\": asset,\n                \"is_buy\": is_buy,\n                \"sz\": size,\n                \"price\": price,\n                \"current_value\": current_value,\n                \"target_value\": target_value,\n                \"delta_value\": delta_value,\n                \"type\": trade_type,\n            }\n\n            # Re-evaluate min notional AFTER rounding size\n            if abs(size * price) &lt; min_trade_value:\n                # Below minimum. If not forcing or not a pure close-to-zero scenario, skip.\n                if not force or target_value != 0:\n                    trade_data[\"skipped\"] = True\n                    trade_data[\"skip_reason\"] = f\"Below minimum ${min_trade_value}\"\n                    skipped_trades.append(trade_data)\n                else:\n                    forced, reason = self._compose_force_close_trades(\n                        asset, price, current_value, min_trade_value\n                    )\n                    if forced is None:\n                        skipped_trades.append(\n                            {\n                                \"coin\": asset,\n                                \"target_value\": target_value,\n                                \"skipped\": True,\n                                \"skip_reason\": reason\n                                or \"Force close composition failed\",\n                            }\n                        )\n                    else:\n                        trades.extend(forced)\n            else:\n                # Add to executable trades\n                trades.append(trade_data)\n\n        return trades, skipped_trades\n\n    def _sort_trades_for_leverage_reduction(\n        self, trades: list[dict[str, Any]]\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Return trades ordered to reduce leverage first using explicit trade types.\n\n        Priority: close (0), reduce/flip (1), increase (2), open (3). Stable ordering within groups.\n        \"\"\"\n        priority = {\"close\": 0, \"reduce\": 1, \"flip\": 1, \"increase\": 2, \"open\": 3}\n\n        def sort_key(t: dict[str, Any]):\n            # Forced close chains must execute in sequence: increase (0) then close (1)\n            if t.get(\"force\"):\n                return (0, t.get(\"force_id\", \"\"), t.get(\"force_seq\", 0))\n            return (1, priority.get(t.get(\"type\", \"increase\"), 2), 0)\n\n        return sorted(trades, key=sort_key)\n\n    def _compose_force_close_trades(\n        self, coin: str, price: float, current_value: float, min_trade_value: float\n    ) -&gt; tuple[list[dict[str, Any]] | None, str | None]:\n        \"\"\"Compose the two-step forced close for sub-minimum closes.\n        i.e. if we have a position of less than $10, we want to close it to $0, we need to increase the position\n        to at least $10, then close it to $0.\n\n        Returns (trades, None) on success or (None, reason) on failure.\n        \"\"\"\n        rounded_up = self._round_size_up_to_min_notional(coin, min_trade_value, price)\n        if rounded_up is None:\n            return None, \"Unknown szDecimals (meta)\"\n        min_increase_sz, _ = rounded_up\n\n        increase_is_buy = current_value &gt; 0\n        force_id = f\"force_close:{coin}\"\n\n        step1 = {\n            \"coin\": coin,\n            \"is_buy\": increase_is_buy,\n            \"sz\": min_increase_sz,\n            \"price\": price,\n            \"current_value\": current_value,\n            \"target_value\": current_value\n            + (\n                min_increase_sz * price\n                if current_value &gt;= 0\n                else -min_increase_sz * price\n            ),\n            \"delta_value\": min_increase_sz * price\n            if increase_is_buy\n            else -(min_increase_sz * price),\n            \"type\": \"increase\",\n            \"force\": True,\n            \"force_id\": force_id,\n            \"force_seq\": 0,\n        }\n\n        total_notional_to_close = abs(current_value) + (min_increase_sz * price)\n        close_is_buy = not increase_is_buy\n        close_sz_rounded = self._round_size(coin, total_notional_to_close / price)\n        if close_sz_rounded is None:\n            return None, \"Unknown szDecimals (meta)\"\n        close_sz, _ = close_sz_rounded\n\n        step2 = {\n            \"coin\": coin,\n            \"is_buy\": close_is_buy,\n            \"sz\": close_sz,\n            \"price\": price,\n            \"current_value\": current_value\n            + (\n                min_increase_sz * price\n                if increase_is_buy\n                else -(min_increase_sz * price)\n            ),\n            \"target_value\": 0,\n            \"delta_value\": total_notional_to_close\n            if close_is_buy\n            else -total_notional_to_close,\n            \"type\": \"close\",\n            \"force\": True,\n            \"force_id\": force_id,\n            \"force_seq\": 1,\n        }\n\n        # Ensure both meet minimum notional\n        if (step1[\"sz\"] * price) &lt; min_trade_value or (\n            step2[\"sz\"] * price\n        ) &lt; min_trade_value:\n            return (\n                None,\n                f\"Below minimum even after force composition (${min_trade_value})\",\n            )\n\n        return [step1, step2], None\n\n    def _round_size_up_to_min_notional(\n        self, coin: str, target_notional: float, price: float\n    ) -&gt; tuple[float, int] | None:\n        \"\"\"Return (size, decimals) such that size*price &gt;= target_notional after rounding to szDecimals.\n\n        Rounds up to the nearest step defined by szDecimals to satisfy the notional constraint.\n        \"\"\"\n        sz_decimals = self._get_sz_decimals(coin)\n        if sz_decimals is None:\n            return None\n        raw_size = target_notional / price if price &gt; 0 else 0\n        if raw_size &lt;= 0:\n            return (0.0, sz_decimals)\n        step = 10 ** (-sz_decimals)\n        # Avoid floating imprecision by working in integer steps\n        steps_needed = math.ceil(raw_size / step)\n        rounded_up_size = steps_needed * step\n        # Round to the allowed decimals to avoid long floats\n        rounded_up_size = round(rounded_up_size, sz_decimals)\n        return rounded_up_size, sz_decimals\n\n    def _execute_trades(self, trades: list[dict[str, Any]]) -&gt; list[dict[str, Any]]:\n        \"\"\"Executes a list of trades using the SDK's market_open for robustness.\"\"\"\n        if not trades:\n            return []\n\n        successful_trades = []\n        failed_trades = []\n\n        # Show progress during execution\n        self.callbacks.info(f\"Executing {len(trades)} trades...\")\n\n        for i, trade in enumerate(trades, 1):\n            # Notify callback of trade start\n            self.callbacks.on_trade_start(i, len(trades), trade)\n\n            try:\n                self.logger.debug(f\"Executing trade: {trade}\")\n                # Pass vault address if trading on behalf of a vault/subaccount.\n                result = self.exchange.market_open(\n                    name=trade[\"coin\"],\n                    is_buy=trade[\"is_buy\"],\n                    sz=trade[\"sz\"],  # Already a float\n                    slippage=self.config.execution.slippage_tolerance,\n                )\n\n                statuses = (\n                    result.get(\"response\", {}).get(\"data\", {}).get(\"statuses\", [])\n                )\n\n                # Check for filled orders\n                filled_data = None\n                for status in statuses:\n                    if \"filled\" in status:\n                        filled_data = status[\"filled\"]\n                        break\n\n                if filled_data:\n                    # Extract fill details\n                    float(filled_data.get(\"totalSz\", trade[\"sz\"]))\n                    avg_px = float(filled_data.get(\"avgPx\", trade[\"price\"]))\n\n                    # Calculate slippage\n                    if trade[\"is_buy\"]:\n                        slippage_pct = (\n                            (avg_px - trade[\"price\"]) / trade[\"price\"]\n                        ) * 100\n                    else:\n                        slippage_pct = (\n                            (trade[\"price\"] - avg_px) / trade[\"price\"]\n                        ) * 100\n\n                    self.callbacks.on_trade_fill(trade, filled_data, slippage_pct)\n\n                    successful_trades.append(\n                        {\n                            **trade,\n                            \"fill_data\": filled_data,\n                            \"slippage_pct\": slippage_pct,\n                        }\n                    )\n                else:\n                    # Handle errors or unfilled orders\n                    errors = [s.get(\"error\") for s in statuses if \"error\" in s]\n                    error_msg = errors[0] if errors else \"Order not filled\"\n\n                    self.callbacks.on_trade_fail(trade, error_msg)\n                    failed_trades.append(trade)\n\n            except Exception as e:\n                self.callbacks.on_trade_fail(trade, str(e))\n                self.logger.error(f\"Error executing trade for {trade['coin']}: {e}\")\n                failed_trades.append(trade)\n\n        # Notify callback of batch completion\n        self.callbacks.on_batch_complete(successful_trades, failed_trades)\n\n        return successful_trades\n\n    def load_state(self) -&gt; datetime | None:\n        \"\"\"Public wrapper to load last rebalance timestamp.\"\"\"\n        return self._load_state()\n\n    def save_state(self, last_rebalance_date: datetime) -&gt; None:\n        \"\"\"Public wrapper to persist last rebalance timestamp.\"\"\"\n        self._save_state(last_rebalance_date)\n\n    def compute_next_rebalance_time(\n        self, last_rebalance_date: datetime | None, now: datetime | None = None\n    ) -&gt; datetime:\n        \"\"\"Compute the next scheduled rebalance timestamp in UTC.\n\n        Rules:\n        - If this is the first run (no last date): schedule for today at configured time; if\n          already past that time, return \"now\" to indicate it is due immediately.\n        - Otherwise: schedule exactly every_n_days after the last rebalance date, at the\n          configured time.\n        \"\"\"\n        cfg = self.config.portfolio.rebalancing\n        now_utc = now or datetime.now(timezone.utc)\n\n        hour, minute = map(int, cfg.at_time.split(\":\"))\n        rebalance_time = time(hour=hour, minute=minute)\n\n        if last_rebalance_date is None:\n            today_at = datetime.combine(\n                now_utc.date(), rebalance_time, tzinfo=timezone.utc\n            )\n            return today_at if now_utc &lt; today_at else now_utc\n\n        next_date = last_rebalance_date.date() + timedelta(days=cfg.every_n_days)\n        return datetime.combine(next_date, rebalance_time, tzinfo=timezone.utc)\n\n    def _load_state(self) -&gt; datetime | None:\n        \"\"\"Load the last rebalance date from persistent state.\"\"\"\n        import json\n        import os\n\n        state_file = \".cc_liquid_state.json\"\n        if not os.path.exists(state_file):\n            return None\n\n        try:\n            with open(state_file) as f:\n                state = json.load(f)\n                last_date = datetime.fromisoformat(state.get(\"last_rebalance_date\"))\n                return last_date\n        except Exception as e:\n            self.logger.warning(f\"Could not load state file: {e}\")\n            return None\n\n    def _save_state(self, last_rebalance_date: datetime):\n        \"\"\"Save the last rebalance date to persistent state.\"\"\"\n        import json\n\n        state_file = \".cc_liquid_state.json\"\n        with open(state_file, \"w\") as f:\n            json.dump({\"last_rebalance_date\": last_rebalance_date.isoformat()}, f)\n\n    def _load_predictions(self) -&gt; pl.DataFrame | None:\n        \"\"\"Load predictions based on configured data source.\"\"\"\n        try:\n            if self.config.data.source == \"local\":\n                # Use local file\n                predictions = DataLoader.from_file(\n                    self.config.data.path,\n                    date_col=self.config.data.date_column,\n                    id_col=self.config.data.asset_id_column,\n                    pred_col=self.config.data.prediction_column,\n                )\n            elif self.config.data.source == \"crowdcent\":\n                # Download and use CrowdCent meta model\n                predictions = DataLoader.from_crowdcent_api(\n                    api_key=self.config.CROWDCENT_API_KEY,\n                    download_path=self.config.data.path,\n                    date_col=self.config.data.date_column,\n                    id_col=self.config.data.asset_id_column,\n                    pred_col=self.config.data.prediction_column,\n                )\n            elif self.config.data.source == \"numerai\":\n                # Download and use Numerai meta model\n                predictions = DataLoader.from_numerai_api(\n                    download_path=self.config.data.path,\n                    date_col=self.config.data.date_column,\n                    id_col=self.config.data.asset_id_column,\n                    pred_col=self.config.data.prediction_column,\n                )\n            else:\n                raise ValueError(f\"Unknown data source: {self.config.data.source}\")\n\n            return predictions\n\n        except Exception as e:\n            self.logger.error(f\"Error loading predictions: {e}\")\n            return None\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.compute_next_rebalance_time","title":"<code>compute_next_rebalance_time(last_rebalance_date, now=None)</code>","text":"<p>Compute the next scheduled rebalance timestamp in UTC.</p> <p>Rules: - If this is the first run (no last date): schedule for today at configured time; if   already past that time, return \"now\" to indicate it is due immediately. - Otherwise: schedule exactly every_n_days after the last rebalance date, at the   configured time.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def compute_next_rebalance_time(\n    self, last_rebalance_date: datetime | None, now: datetime | None = None\n) -&gt; datetime:\n    \"\"\"Compute the next scheduled rebalance timestamp in UTC.\n\n    Rules:\n    - If this is the first run (no last date): schedule for today at configured time; if\n      already past that time, return \"now\" to indicate it is due immediately.\n    - Otherwise: schedule exactly every_n_days after the last rebalance date, at the\n      configured time.\n    \"\"\"\n    cfg = self.config.portfolio.rebalancing\n    now_utc = now or datetime.now(timezone.utc)\n\n    hour, minute = map(int, cfg.at_time.split(\":\"))\n    rebalance_time = time(hour=hour, minute=minute)\n\n    if last_rebalance_date is None:\n        today_at = datetime.combine(\n            now_utc.date(), rebalance_time, tzinfo=timezone.utc\n        )\n        return today_at if now_utc &lt; today_at else now_utc\n\n    next_date = last_rebalance_date.date() + timedelta(days=cfg.every_n_days)\n    return datetime.combine(next_date, rebalance_time, tzinfo=timezone.utc)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.execute_plan","title":"<code>execute_plan(plan)</code>","text":"<p>Execute a precomputed plan, returning structured results.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def execute_plan(self, plan: dict) -&gt; dict:\n    \"\"\"Execute a precomputed plan, returning structured results.\"\"\"\n    trades: list[dict] = plan.get(\"trades\", [])\n    if not trades:\n        # Nothing to do\n        return {\"successful_trades\": [], \"all_trades\": trades}\n\n    # Prioritize leverage reduction: execute closes/reductions (and flips) before opens\n    trades = self._sort_trades_for_leverage_reduction(trades)\n\n    self.callbacks.info(f\"Starting execution of {len(trades)} trades...\")\n    successful_trades = self._execute_trades(trades)\n    return {\"successful_trades\": successful_trades, \"all_trades\": trades}\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_account_value","title":"<code>get_account_value()</code>","text":"<p>Retrieves the total account value in USD.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_account_value(self) -&gt; float:\n    \"\"\"Retrieves the total account value in USD.\"\"\"\n    user_state = self.get_user_state()\n    return float(user_state[\"marginSummary\"][\"accountValue\"])\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_portfolio_info","title":"<code>get_portfolio_info()</code>","text":"<p>Get complete portfolio information as structured data.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_portfolio_info(self) -&gt; PortfolioInfo:\n    \"\"\"Get complete portfolio information as structured data.\"\"\"\n    try:\n        user_state = self.get_user_state()\n    except Exception as e:\n        self.logger.warning(f\"Could not get user state: {e}\")\n        # Return empty portfolio if we can't connect\n        return PortfolioInfo(\n            account=AccountInfo(\n                account_value=0,\n                total_position_value=0,\n                margin_used=0,\n                free_collateral=0,\n                cash_balance=0,\n                withdrawable=0,\n                current_leverage=0,\n            ),\n            positions=[],\n        )\n\n    margin_summary = user_state.get(\"marginSummary\", {}) if user_state else {}\n    all_mids = self.info.all_mids() if user_state else {}\n\n    # Build account info\n    account_info = AccountInfo(\n        account_value=float(margin_summary.get(\"accountValue\", 0)),\n        total_position_value=float(margin_summary.get(\"totalNtlPos\", 0)),\n        margin_used=float(margin_summary.get(\"totalMarginUsed\", 0)),\n        free_collateral=float(margin_summary.get(\"accountValue\", 0))\n        - float(margin_summary.get(\"totalMarginUsed\", 0)),\n        cash_balance=float(margin_summary.get(\"totalRawUsd\", 0)),\n        withdrawable=float(user_state.get(\"withdrawable\", 0)),\n        current_leverage=float(margin_summary.get(\"totalNtlPos\", 0))\n        / float(margin_summary.get(\"accountValue\", 1))\n        if float(margin_summary.get(\"accountValue\", 0)) &gt; 0\n        else 0,\n        raw_margin_summary=margin_summary,\n    )\n\n    # Add cross margin info if available\n    cross_margin = user_state.get(\"crossMarginSummary\")\n    if cross_margin:\n        account_info.cross_leverage = (\n            float(cross_margin.get(\"accountValue\", 0))\n            / float(margin_summary.get(\"accountValue\", 1))\n            if float(margin_summary.get(\"accountValue\", 0)) &gt; 0\n            else 0\n        )\n        account_info.cross_margin_used = float(\n            cross_margin.get(\"totalMarginUsed\", 0)\n        )\n        account_info.cross_maintenance_margin = float(\n            cross_margin.get(\"totalMaintenanceMargin\", 0)\n        )\n        account_info.raw_cross_margin_summary = cross_margin\n\n    # Build positions list\n    positions = []\n    for position_data in user_state.get(\"assetPositions\", []):\n        pos = position_data.get(\"position\", {})\n        size = float(pos.get(\"szi\", 0))\n\n        if size == 0:\n            continue\n\n        coin = pos[\"coin\"]\n        entry_px = float(pos.get(\"entryPx\", 0))\n        mark_px = float(all_mids.get(coin, entry_px))\n        position_value = abs(size * mark_px)\n\n        # Calculate unrealized PnL\n        if size &gt; 0:\n            unrealized_pnl = (mark_px - entry_px) * size\n            side = \"LONG\"\n        else:\n            unrealized_pnl = (entry_px - mark_px) * abs(size)\n            side = \"SHORT\"\n\n        return_pct = (\n            (unrealized_pnl / (abs(size) * entry_px) * 100) if entry_px &gt; 0 else 0\n        )\n\n        positions.append(\n            Position(\n                coin=coin,\n                side=side,\n                size=abs(size),\n                entry_price=entry_px,\n                mark_price=mark_px,\n                value=position_value,\n                unrealized_pnl=unrealized_pnl,\n                return_pct=return_pct,\n                liquidation_price=float(pos[\"liquidationPx\"])\n                if \"liquidationPx\" in pos and pos[\"liquidationPx\"] is not None\n                else None,\n                margin_used=float(pos[\"marginUsed\"])\n                if \"marginUsed\" in pos and pos[\"marginUsed\"] is not None\n                else None,\n            )\n        )\n\n    return PortfolioInfo(account=account_info, positions=positions)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_positions","title":"<code>get_positions()</code>","text":"<p>Retrieves the user's open positions as a dict.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_positions(self) -&gt; dict[str, Any]:\n    \"\"\"Retrieves the user's open positions as a dict.\"\"\"\n    user_state = self.get_user_state()\n    positions = {}\n    for position_data in user_state.get(\"assetPositions\", []):\n        position = position_data.get(\"position\", {})\n        if float(position.get(\"szi\", 0)) != 0:\n            positions[position[\"coin\"]] = position\n    return positions\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_user_state","title":"<code>get_user_state()</code>","text":"<p>Retrieves the current state of the user's account.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_user_state(self) -&gt; dict[str, Any]:\n    \"\"\"Retrieves the current state of the user's account.\"\"\"\n    # Always query Info using the portfolio owner: vault (if set) or master address.\n    # Never use the agent/signer address for Info, as it has no balances.\n    owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n    if not owner:\n        raise ValueError(\n            \"Missing portfolio owner. Set HYPERLIQUID_VAULT_ADDRESS or HYPERLIQUID_ADDRESS.\"\n        )\n    return self.info.user_state(owner)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.load_state","title":"<code>load_state()</code>","text":"<p>Public wrapper to load last rebalance timestamp.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def load_state(self) -&gt; datetime | None:\n    \"\"\"Public wrapper to load last rebalance timestamp.\"\"\"\n    return self._load_state()\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.plan_close_all_positions","title":"<code>plan_close_all_positions(*, force=False)</code>","text":"<p>Plan to close all open positions (return to cash) without executing orders.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def plan_close_all_positions(self, *, force: bool = False) -&gt; dict:\n    \"\"\"Plan to close all open positions (return to cash) without executing orders.\"\"\"\n    current_positions = self.get_positions()\n\n    if not current_positions:\n        self.callbacks.info(\"No open positions to close.\")\n        return {\n            \"target_positions\": {},\n            \"trades\": [],\n            \"skipped_trades\": [],\n            \"account_value\": self.get_account_value(),\n            \"leverage\": self.config.portfolio.target_leverage,\n        }\n\n    self.callbacks.info(\"Closing all positions to return to cash...\")\n\n    # Create target positions of 0 for all current positions\n    target_positions = {coin: 0 for coin in current_positions.keys()}\n    trades, skipped_trades = self._calculate_trades(\n        target_positions, current_positions, force=force\n    )\n\n    account_value = self.get_account_value()\n    leverage = self.config.portfolio.target_leverage\n    return {\n        \"target_positions\": target_positions,\n        \"trades\": trades,\n        \"skipped_trades\": skipped_trades,\n        \"account_value\": account_value,\n        \"leverage\": leverage,\n    }\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.plan_rebalance","title":"<code>plan_rebalance(predictions=None)</code>","text":"<p>Compute a rebalancing plan without executing orders.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def plan_rebalance(self, predictions: pl.DataFrame | None = None) -&gt; dict:\n    \"\"\"Compute a rebalancing plan without executing orders.\"\"\"\n    # Load predictions if not provided\n    if predictions is None:\n        self.callbacks.info(\"Loading predictions...\")\n        predictions = self._load_predictions()\n\n        if predictions is None or predictions.is_empty():\n            self.callbacks.error(\"No predictions available, cannot rebalance\")\n            return {\n                \"target_positions\": {},\n                \"trades\": [],\n                \"skipped_trades\": [],\n                \"account_value\": 0.0,\n                \"leverage\": self.config.portfolio.target_leverage,\n            }\n\n        # Display prediction info\n        unique_assets = predictions[self.config.data.asset_id_column].n_unique()\n        latest_data = predictions[self.config.data.date_column].max()\n        self.callbacks.info(\n            f\"Loaded predictions for {unique_assets} assets (latest: {latest_data})\"\n        )\n\n    # Asset Selection, Position Calculation, and Trade Generation\n    target_positions = self._get_target_positions(predictions)\n    current_positions = self.get_positions()\n    trades, skipped_trades = self._calculate_trades(\n        target_positions, current_positions\n    )\n\n    # Build plan (including skipped trades)\n    account_value = self.get_account_value()\n    leverage = self.config.portfolio.target_leverage\n    return {\n        \"target_positions\": target_positions,\n        \"trades\": trades,\n        \"skipped_trades\": skipped_trades,\n        \"account_value\": account_value,\n        \"leverage\": leverage,\n    }\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.save_state","title":"<code>save_state(last_rebalance_date)</code>","text":"<p>Public wrapper to persist last rebalance timestamp.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def save_state(self, last_rebalance_date: datetime) -&gt; None:\n    \"\"\"Public wrapper to persist last rebalance timestamp.\"\"\"\n    self._save_state(last_rebalance_date)\n</code></pre>"},{"location":"api/python/#callback-protocols","title":"Callback protocols","text":""},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks","title":"<code>CCLiquidCallbacks</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for trader callbacks to abstract UI/UX concerns.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>class CCLiquidCallbacks(Protocol):\n    \"\"\"Protocol for trader callbacks to abstract UI/UX concerns.\"\"\"\n\n    # High-level lifecycle methods\n    def ask_confirmation(self, message: str) -&gt; bool:\n        \"\"\"Ask user for confirmation.\"\"\"\n        ...\n\n    def info(self, message: str) -&gt; None:\n        \"\"\"Display info message.\"\"\"\n        ...\n\n    def warn(self, message: str) -&gt; None:\n        \"\"\"Display warning message.\"\"\"\n        ...\n\n    def error(self, message: str) -&gt; None:\n        \"\"\"Display error message.\"\"\"\n        ...\n\n    def on_config_override(self, overrides: list[str]) -&gt; None:\n        \"\"\"Display applied configuration overrides.\"\"\"\n        ...\n\n    # Trade execution progress hooks\n    def on_trade_start(self, idx: int, total: int, trade: dict[str, Any]) -&gt; None:\n        \"\"\"Called when a trade execution starts.\"\"\"\n        ...\n\n    def on_trade_fill(\n        self, trade: dict[str, Any], fill_data: dict[str, Any], slippage_pct: float\n    ) -&gt; None:\n        \"\"\"Called when a trade is filled.\"\"\"\n        ...\n\n    def on_trade_fail(self, trade: dict[str, Any], reason: str) -&gt; None:\n        \"\"\"Called when a trade fails.\"\"\"\n        ...\n\n    def on_batch_complete(self, success: list[dict], failed: list[dict]) -&gt; None:\n        \"\"\"Called when a batch of trades completes.\"\"\"\n        ...\n\n    def show_trade_plan(\n        self,\n        target_positions: dict,\n        trades: list,\n        account_value: float,\n        leverage: float,\n    ) -&gt; None:\n        \"\"\"Display the trade plan before execution.\"\"\"\n        ...\n\n    def show_execution_summary(\n        self,\n        successful_trades: list[dict],\n        all_trades: list[dict],\n        target_positions: dict,\n        account_value: float,\n    ) -&gt; None:\n        \"\"\"Display execution summary after trades complete.\"\"\"\n        ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.ask_confirmation","title":"<code>ask_confirmation(message)</code>","text":"<p>Ask user for confirmation.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def ask_confirmation(self, message: str) -&gt; bool:\n    \"\"\"Ask user for confirmation.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.error","title":"<code>error(message)</code>","text":"<p>Display error message.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def error(self, message: str) -&gt; None:\n    \"\"\"Display error message.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.info","title":"<code>info(message)</code>","text":"<p>Display info message.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def info(self, message: str) -&gt; None:\n    \"\"\"Display info message.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_batch_complete","title":"<code>on_batch_complete(success, failed)</code>","text":"<p>Called when a batch of trades completes.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_batch_complete(self, success: list[dict], failed: list[dict]) -&gt; None:\n    \"\"\"Called when a batch of trades completes.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_config_override","title":"<code>on_config_override(overrides)</code>","text":"<p>Display applied configuration overrides.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_config_override(self, overrides: list[str]) -&gt; None:\n    \"\"\"Display applied configuration overrides.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_trade_fail","title":"<code>on_trade_fail(trade, reason)</code>","text":"<p>Called when a trade fails.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_trade_fail(self, trade: dict[str, Any], reason: str) -&gt; None:\n    \"\"\"Called when a trade fails.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_trade_fill","title":"<code>on_trade_fill(trade, fill_data, slippage_pct)</code>","text":"<p>Called when a trade is filled.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_trade_fill(\n    self, trade: dict[str, Any], fill_data: dict[str, Any], slippage_pct: float\n) -&gt; None:\n    \"\"\"Called when a trade is filled.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_trade_start","title":"<code>on_trade_start(idx, total, trade)</code>","text":"<p>Called when a trade execution starts.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_trade_start(self, idx: int, total: int, trade: dict[str, Any]) -&gt; None:\n    \"\"\"Called when a trade execution starts.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.show_execution_summary","title":"<code>show_execution_summary(successful_trades, all_trades, target_positions, account_value)</code>","text":"<p>Display execution summary after trades complete.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def show_execution_summary(\n    self,\n    successful_trades: list[dict],\n    all_trades: list[dict],\n    target_positions: dict,\n    account_value: float,\n) -&gt; None:\n    \"\"\"Display execution summary after trades complete.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.show_trade_plan","title":"<code>show_trade_plan(target_positions, trades, account_value, leverage)</code>","text":"<p>Display the trade plan before execution.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def show_trade_plan(\n    self,\n    target_positions: dict,\n    trades: list,\n    account_value: float,\n    leverage: float,\n) -&gt; None:\n    \"\"\"Display the trade plan before execution.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.warn","title":"<code>warn(message)</code>","text":"<p>Display warning message.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def warn(self, message: str) -&gt; None:\n    \"\"\"Display warning message.\"\"\"\n    ...\n</code></pre>"}]}